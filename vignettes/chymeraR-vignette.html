<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Henry Ward" />


<title>chymeraR-vignette</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">chymeraR-vignette</h1>
<h4 class="author">Henry Ward</h4>



<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>The chymeraR package contains all the computational tools you need to process, score and analyze combinatorial CRISPR screening data.</p>
<p>This document will guide you through the complete process of scoring a published combinatorial screening dataset. This dataset comprises combinatorial CRISPR screens performed with the CHyMErA experimental platform in two different cell lines, HAP1 and RPE1, across a wild-type condition and a Torin1-treated condition, with read counts taken at two different timepoints for each cell line (T12 and T18 for HAP1, T18 and T24 for RPE1). Each guide in the dataset, represented by a single row, has associated read counts for the knockout of regions specified by a Cas9 sequence and a Cas12a sequence. The first set of columns in the dataset contain metadata for guide pairs, and the remaining numeric columns contain raw read counts for the guide pairs across every screen.</p>
<p>The guide library used to generate this data contains several different types of guides. For this vignette, we will be interested inscoring guides that target the same gene twice (“dual-targeting” guides) and guides that target each gene of a paralogous gene pair separately (“paralog” guides). Additionally, scoring the paralog guides requires comparisons against a third set of guides that target a gene’s exonic region in addition to a relatively distant intergenic region (“single-targeting” guides).</p>
<p>In-depth descriptions of this dataset and how it was originally scored are available in <a href="https://www.nature.com/articles/s41587-020-0437-z">Gonatopoulos-Pournatzis et al.</a></p>
<div id="important-publications" class="section level3">
<h3>Important publications</h3>
<p>Please refer to the following publications for more information on the CHyMErA experimental platform, CRISPR screens and scoring them, or alternative approaches for scoring combinatorial CRISPR screening data.</p>
<p><a href="https://www.nature.com/articles/s41587-020-0437-z">Gonatopoulos-Pournatzis et al.</a></p>
<p>max’s scoring paper</p>
<p>flex</p>
<p>gemini for an alternative scoring approach?</p>
<p>CRISPR screen overview papers?</p>
</div>
<div id="prerequisites" class="section level3">
<h3>Prerequisites</h3>
<p>To follow this vignette, familiarity with CRISPR screening technology is strongly recommended. Familiarity with combinatorial CRISPR screening platforms or other ways to score CRISPR screening data is recommended, but not required.</p>
<p>The only additional package needed to follow this vignette is ggplot2.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">install.packages</span>(<span class="st">&quot;ggplot2&quot;</span>)</a></code></pre></div>
</div>
</div>
<div id="walkthrough" class="section level2">
<h2>Walkthrough</h2>
<div id="setting-up" class="section level3">
<h3>Setting up</h3>
<p>First, we want to load the chymera package, ggplot2, and the aforementioned dataset into our workspace.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">library</span>(chymeraR)</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">library</span>(ggplot2)</a></code></pre></div>
<p>Next, let’s rename the aforementioned dataset that comes bundled with chymeraR for brevity. At the same time, let’s also create output folders to hold QC plots and our final results.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co"># Renames dataset</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">df &lt;-<span class="st"> </span>chymera_paralog</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="co"># Makes output folders if nonexistent</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">output_folder &lt;-<span class="st"> </span><span class="kw">file.path</span>(<span class="st">&quot;output&quot;</span>, <span class="st">&quot;vignette&quot;</span>)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">qc_folder &lt;-<span class="st"> </span><span class="kw">file.path</span>(output_folder, <span class="st">&quot;qc&quot;</span>)</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">lfc_folder &lt;-<span class="st"> </span><span class="kw">file.path</span>(qc_folder, <span class="st">&quot;lfc_plots&quot;</span>)</a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="cf">if</span> (<span class="op">!</span><span class="kw">dir.exists</span>(output_folder)) { <span class="kw">dir.create</span>(output_folder, <span class="dt">recursive =</span> <span class="ot">TRUE</span>) }</a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="cf">if</span> (<span class="op">!</span><span class="kw">dir.exists</span>(qc_folder)) { <span class="kw">dir.create</span>(qc_folder) }</a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="cf">if</span> (<span class="op">!</span><span class="kw">dir.exists</span>(lfc_folder)) { <span class="kw">dir.create</span>(lfc_folder) }</a></code></pre></div>
<p>We need to put together a list of screens so that the rest of the pipeline knows which technical replicates belong to which screen. To do this, we call the <code>add_screen</code> function. This requires you to give each screen a name - for instance, HAP1_T12 - and a list of column names in the dataset of interest that belong to the screen. We first want to list names for our T0 screens, which have no technical replicates. For subsequent calls to <code>add_screen</code>, we can pass previous results in as the first argument to build up the list of screens, and will no longer have to call parameters by name.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1">screens &lt;-<span class="st"> </span><span class="kw">add_screen</span>(<span class="dt">name =</span> <span class="st">&quot;HAP1_T0&quot;</span>, <span class="dt">replicates =</span> <span class="st">&quot;HAP1.T0&quot;</span>)</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">screens &lt;-<span class="st"> </span><span class="kw">add_screen</span>(screens, <span class="st">&quot;RPE1_T0&quot;</span>, <span class="st">&quot;RPE1.T0&quot;</span>)</a></code></pre></div>
<p>Because we want to normalize the rest of the screens to their respective T0 screens to get log fold-changes (LFCs), we add the name of the screen that we want to normalize to in the final parameter of the <code>add_screen</code> function (the <code>normalize_name</code> parameter). All of these screens from later timepoints also have three technical replicates, A, B, and C, which are separately normalized to T0s and are automatically averaged farther downstream in the pipeline before computing results.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1">screens &lt;-<span class="st"> </span><span class="kw">add_screen</span>(screens, <span class="st">&quot;HAP1_T12&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;HAP1.T12A&quot;</span>, <span class="st">&quot;HAP1.T12B&quot;</span>, <span class="st">&quot;HAP1.T12C&quot;</span>), <span class="st">&quot;HAP1_T0&quot;</span>)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">screens &lt;-<span class="st"> </span><span class="kw">add_screen</span>(screens, <span class="st">&quot;HAP1_T18&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;HAP1.T18A&quot;</span>, <span class="st">&quot;HAP1.T18B&quot;</span>, <span class="st">&quot;HAP1.T18C&quot;</span>), <span class="st">&quot;HAP1_T0&quot;</span>)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">screens &lt;-<span class="st"> </span><span class="kw">add_screen</span>(screens, <span class="st">&quot;Torin_T12&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;HAP1.Torin.T12A&quot;</span>, <span class="st">&quot;HAP1.Torin.T12B&quot;</span>, <span class="st">&quot;HAP1.Torin.T12C&quot;</span>), <span class="st">&quot;HAP1_T0&quot;</span>)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">screens &lt;-<span class="st"> </span><span class="kw">add_screen</span>(screens, <span class="st">&quot;Torin_T18&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;HAP1.Torin.T18A&quot;</span>, <span class="st">&quot;HAP1.Torin.T18B&quot;</span>, <span class="st">&quot;HAP1.Torin.T18C&quot;</span>), <span class="st">&quot;HAP1_T0&quot;</span>)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">screens &lt;-<span class="st"> </span><span class="kw">add_screen</span>(screens, <span class="st">&quot;RPE1_T18&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;RPE1.T18A&quot;</span>, <span class="st">&quot;RPE1.T18B&quot;</span>, <span class="st">&quot;RPE1.T18C&quot;</span>), <span class="st">&quot;RPE1_T0&quot;</span>)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">screens &lt;-<span class="st"> </span><span class="kw">add_screen</span>(screens, <span class="st">&quot;RPE1_T24&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;RPE1.T24A&quot;</span>, <span class="st">&quot;RPE1.T24B&quot;</span>, <span class="st">&quot;RPE1.T24C&quot;</span>), <span class="st">&quot;RPE1_T0&quot;</span>)</a></code></pre></div>
</div>
<div id="processing-and-qc" class="section level3">
<h3>Processing and QC</h3>
<p>The first thing we want to do for any experiment is generate plots of raw read counts for all technical replicates. The easiest way to do this is to make histograms of log-scaled read counts for each replicate. A single function in chymeraR, <code>plot_screen_reads</code>, takes care of this for all screens. Like other plotting functions that output multiple plots in chymeraR, <code>plot_screen_reads</code> requires you to specify a folder to save plots to. Because these are QC plots, we will output them to the previously-created QC folder.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">plot_screen_reads</span>(df, screens, qc_folder)</a></code></pre></div>
<p>Now we need to normalize each screen in three different ways:</p>
<ol style="list-style-type: decimal">
<li>To their respective T0 screens (getting LFCs)</li>
<li>To the respective depth of each technical replicate</li>
<li>By removing guides that are too lowly or highly-expressed at T0</li>
</ol>
<p>One workhorse function, <code>normalize_screens</code>, automatically performs all of these normalization steps. The function infers which columns of <code>df</code> need to be normalized to which T0 screens based on the <code>normalize_name</code> parameter of each screen in <code>screens</code> (screens without this optional parameter will not be normalized to other screens). Log-scaling and depth-normalization is performed on each screen regardless of the <code>normalize_name</code> parameter. For example, after normalization T0 columns in <code>df</code> will contain log-scaled, depth-normalized read counts, whereas columns from later timepoints will contain depth-normalized LFCs compared to their respective T0s.</p>
<p>This function additionally removes guides that are lowly-expressed or highly-expressed at T0. To set screens to filter by, pass a list of their names to the <code>filter_names</code> parameter. For typical experiments we recommend you pass T0 screens to this parameter. To set minimum and maximum read count thresholds for guides in the T0 screens, pass numbers to the <code>min_reads</code> (default 30) and <code>max_reads</code> (default 10,000) parameters. Guides will not typically exceed the <code>max_reads</code> threshold, but if they do, it is likely a red flag for screen quality.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1">df &lt;-<span class="st"> </span><span class="kw">normalize_screens</span>(df, screens, <span class="dt">filter_names =</span> <span class="kw">c</span>(<span class="st">&quot;HAP1_T0&quot;</span>, <span class="st">&quot;RPE1_T0&quot;</span>), <span class="dt">min_reads =</span> <span class="dv">20</span>)</a></code></pre></div>
<p>The final set of QC plots that we need to make consists of scatterplot comparisons between each pair of technical replicates. To make these, we call <code>plot_rep_comparisons</code>. While it is possible and sometimes could be a good idea to make these before computing LFCs, these results tend to be more consistent after computing LFCs due to depth-normalization, so we recommend making them at this point in the pipeline. Although this function also outputs Pearson correlations between all technical replicates, like all QC plots, manual inspection for potential problematic outlier guides or other red flags or is recommended.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">plot_screen_reads</span>(df, screens, qc_folder)</a></code></pre></div>
<p>Before we can parse the data into a structure more suitable for scoring, we need to ensure that we differentiate gene pairs for intergenic-targeting guides from gene pairs where both guides target the same gene. Not all libraries will require this step, but for our library it’s necessary. Intergenic regions are wrongly denoted for exonic-exonic dual-targeting guides by the symbol “—”, which we will change to “None”.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co"># Converts exonic-exonic pairs to more accurate names. Genes with &quot;---&quot; target intergenic regions, </span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="co"># and genes with &quot;None&quot; target nothing</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">ind &lt;-<span class="st"> </span>(df<span class="op">$</span>Cas9.Guide.Type <span class="op">==</span><span class="st"> &quot;exonic&quot;</span> <span class="op">&amp;</span><span class="st"> </span>df<span class="op">$</span>Cpf1.Guide.Type <span class="op">==</span><span class="st"> &quot;exonic&quot;</span>) <span class="op">&amp;</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="st">  </span>(df<span class="op">$</span>Gene.symbol1 <span class="op">==</span><span class="st"> &quot;---&quot;</span> <span class="op">|</span><span class="st"> </span>df<span class="op">$</span>Gene.symbol2 <span class="op">==</span><span class="st"> &quot;---&quot;</span>)</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">temp &lt;-<span class="st"> </span>df<span class="op">$</span>Gene.symbol1 <span class="op">==</span><span class="st"> &quot;---&quot;</span> <span class="op">&amp;</span><span class="st"> </span>ind</a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="cf">if</span> (<span class="kw">sum</span>(temp)) {</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  df<span class="op">$</span>Gene.symbol1[temp] &lt;-<span class="st"> &quot;None&quot;</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">temp &lt;-<span class="st"> </span>df<span class="op">$</span>Gene.symbol2 <span class="op">==</span><span class="st"> &quot;---&quot;</span> <span class="op">&amp;</span><span class="st"> </span>ind</a>
<a class="sourceLine" id="cb9-10" data-line-number="10"><span class="cf">if</span> (<span class="kw">sum</span>(temp)) {</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">  df<span class="op">$</span>Gene.symbol2[temp] &lt;-<span class="st"> &quot;None&quot;</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">}</a></code></pre></div>
<p>The last thing we need to do before scoring data is parse it into a different structure and split guides by their type. The reason we do this involves the core assumption that orientation (whether Cas9 targets gene A and Cas12a targets gene B, or vice versa) matters for scoring CHyMErA data. Because of this, to make scoring easier for all gene pairs we want to group their guides across each orientation together into a single list ordered by guide IDs. To parse this data, we call the following functions in order:</p>
<ol style="list-style-type: decimal">
<li><code>unique_gene_pairs</code> gets all unique gene pairs in the dataset, passing in the names of the two gene name columns in the dataset</li>
<li><code>retrieve_guides_by_label</code> gets all guides associated with unique gene pairs for every screen according to given gene labels in the columns “Cas9.Guide.Type” and “Cpf1.Guide.Type”. These labels must be one of “exonic”, “intergenic” or “NT” for non-targeting controls. This also appends guide sequences to use as guide IDs (necessary for scoring data with moderated t-testing downstream). The order of parameters matters here - in the code below, “Cas9.Guide.Type” and “Cas9.Guide” are mapped to genes in “Gene.symbol1”, and similarly for the other parameters mapped to “Gene.symbol2”.</li>
<li><code>split_guides_by_type</code> splits all guides according to whether they target the same gene twice (“single_gene_dual_targeted”), a single gene and an intergenic region (“exonic_intergenic”), or two different genes (“exonic_exonic”). Different types of guides necessitate different scoring methods, which are explained in more detail below.</li>
</ol>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co"># Gets gene names and guide counts</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">gene_pairs &lt;-<span class="st"> </span><span class="kw">unique_gene_pairs</span>(df, <span class="st">&quot;Gene.symbol1&quot;</span>, <span class="st">&quot;Gene.symbol2&quot;</span>)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">guides &lt;-<span class="st"> </span><span class="kw">retrieve_guides_by_label</span>(df, gene_pairs, screens, </a>
<a class="sourceLine" id="cb10-4" data-line-number="4">                                   <span class="st">&quot;Gene.symbol1&quot;</span>, <span class="st">&quot;Gene.symbol2&quot;</span>, </a>
<a class="sourceLine" id="cb10-5" data-line-number="5">                                   <span class="st">&quot;Cas9.Guide.Type&quot;</span>, <span class="st">&quot;Cpf1.Guide.Type&quot;</span>,</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">                                   <span class="st">&quot;Cas9.Guide&quot;</span>, <span class="st">&quot;Cpf1.Guide&quot;</span>)</a>
<a class="sourceLine" id="cb10-7" data-line-number="7"></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"><span class="co"># Separates single-targeting and dual-targeting guides</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">temp &lt;-<span class="st"> </span><span class="kw">split_guides_by_type</span>(guides)</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">dual &lt;-<span class="st"> </span>temp[[<span class="st">&quot;single_gene_dual_targeted&quot;</span>]]</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">single &lt;-<span class="st"> </span>temp[[<span class="st">&quot;exonic_intergenic&quot;</span>]]</a>
<a class="sourceLine" id="cb10-12" data-line-number="12">paralogs &lt;-<span class="st"> </span>temp[[<span class="st">&quot;exonic_exonic&quot;</span>]]</a></code></pre></div>
</div>
<div id="dual-targeted-scoring" class="section level3">
<h3>Dual-targeted scoring</h3>
<p>Now that we’ve processed our data, we need to score it. Thankfully, chymeraR makes this step relatively painless. The most important thing to remember during scoring is that different types of guides need to be scored against different null models. Here, we will detail how to <strong>score data in one or more conditions against a control condition.</strong></p>
<p>The data in our library that lends itself to this type of comparison is the dual-targeting data contained in the <code>dual</code> object. We want to compare untreated screens to screens treated with Torin1. To do this, we pass the data, screens, screen names we want to compare to each other (the control screen name comes first), and the type of testing we want to run into the <code>score_conditions_vs_control</code> function. We need to do this twice because we have two separate controls to compare against, although we can pass any number of condition names as a list into the fourth argument of the function. E.g. if we had another drug screen for T12, “BTZ_T12”, we could instead pass <code>c(&quot;Torin_T12&quot;, &quot;BTZ_T12&quot;)</code> into the first function call below.</p>
<p>By default the chosen test is moderated-t with loess correction on residuals enabled, for improved sensitivity. Although chymeraR supports other types of testing, which are documented in the package, because they are less sensitive we do not recommend them at this time.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" data-line-number="1">dual_scores1 &lt;-<span class="st"> </span><span class="kw">score_conditions_vs_control</span>(dual, screens, <span class="st">&quot;HAP1_T12&quot;</span>, <span class="st">&quot;Torin_T12&quot;</span>, </a>
<a class="sourceLine" id="cb11-2" data-line-number="2">                                            <span class="dt">test =</span> <span class="st">&quot;moderated-t&quot;</span>, <span class="dt">loess =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">dual_scores2 &lt;-<span class="st"> </span><span class="kw">score_conditions_vs_control</span>(dual, screens, <span class="st">&quot;HAP1_T18&quot;</span>, <span class="st">&quot;Torin_T18&quot;</span>, </a>
<a class="sourceLine" id="cb11-4" data-line-number="4">                                            <span class="dt">test =</span> <span class="st">&quot;moderated-t&quot;</span>, <span class="dt">loess =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<p>After scoring data, we want to call hits according to user-specific thresholds on FDR and effect size, naming negative effects and positive effects according to the type of screen performed, using the <code>call_significant_response</code> function. The effect size threshold, <code>differential_threshold</code>, is based on the absolute value of the effect. Here, only guides with abs(effect) &lt; 0.5 and fdr &lt; 0.1 will be called as significant hits.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1">dual_scores1 &lt;-<span class="st"> </span><span class="kw">call_significant_response</span>(dual_scores1, <span class="st">&quot;HAP1_T12&quot;</span>, <span class="st">&quot;Torin_T12&quot;</span>,</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">                                          <span class="dt">neg_type =</span> <span class="st">&quot;Sensitizer&quot;</span>, <span class="dt">pos_type =</span> <span class="st">&quot;Suppressor&quot;</span>,</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">                                          <span class="dt">fdr_threshold =</span> <span class="fl">0.1</span>, <span class="dt">differential_threshold =</span> <span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">dual_scores2 &lt;-<span class="st"> </span><span class="kw">call_significant_response</span>(dual_scores2, <span class="st">&quot;HAP1_T18&quot;</span>, <span class="st">&quot;Torin_T18&quot;</span>,</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">                                          <span class="dt">neg_type =</span> <span class="st">&quot;Sensitizer&quot;</span>, <span class="dt">pos_type =</span> <span class="st">&quot;Suppressor&quot;</span>,</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">                                          <span class="dt">fdr_threshold =</span> <span class="fl">0.1</span>, <span class="dt">differential_threshold =</span> <span class="fl">0.5</span>)</a></code></pre></div>
<p>Finally, to finish scoring this data we will generate pretty plots describing differential effects and save both those and the scored data to file. Since these plotting functions only return one plot, they return a ggplot object instead of directly saving to file. Since we renamed the negative and positive effect type labels above, we have to pass our custom labels into the plotting function as well.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="co"># Plots drug response</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">p &lt;-<span class="st"> </span><span class="kw">plot_significant_response</span>(dual_scores1, <span class="st">&quot;HAP1_T12&quot;</span>, <span class="st">&quot;Torin_T12&quot;</span>, <span class="dt">neg_type =</span> <span class="st">&quot;Sensitizer&quot;</span>, <span class="dt">pos_type =</span> <span class="st">&quot;Suppressor&quot;</span>)</a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="kw">ggsave</span>(<span class="kw">file.path</span>(output_folder, <span class="st">&quot;torin_vs_hap1_t12.png&quot;</span>), <span class="dt">width =</span> <span class="dv">10</span>, <span class="dt">height =</span> <span class="dv">7</span>, <span class="dt">dpi =</span> <span class="dv">300</span>)</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">p &lt;-<span class="st"> </span><span class="kw">plot_significant_response</span>(dual_scores2, <span class="st">&quot;HAP1_T18&quot;</span>, <span class="st">&quot;Torin_T18&quot;</span>, <span class="dt">neg_type =</span> <span class="st">&quot;Sensitizer&quot;</span>, <span class="dt">pos_type =</span> <span class="st">&quot;Suppressor&quot;</span>)</a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="kw">ggsave</span>(<span class="kw">file.path</span>(output_folder, <span class="st">&quot;torin_vs_hap1_t18.png&quot;</span>), <span class="dt">width =</span> <span class="dv">10</span>, <span class="dt">height =</span> <span class="dv">7</span>, <span class="dt">dpi =</span> <span class="dv">300</span>)</a>
<a class="sourceLine" id="cb13-6" data-line-number="6"></a>
<a class="sourceLine" id="cb13-7" data-line-number="7"><span class="co"># Writes data to file</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8"><span class="kw">write.table</span>(dual_scores1, <span class="kw">file.path</span>(output_folder, <span class="st">&quot;dual_targeted_gene_calls_t12.tsv&quot;</span>), <span class="dt">sep =</span> <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">            <span class="dt">row.names =</span> <span class="ot">FALSE</span>, <span class="dt">col.names =</span> <span class="ot">TRUE</span>, <span class="dt">quote =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb13-10" data-line-number="10"><span class="kw">write.table</span>(dual_scores2, <span class="kw">file.path</span>(output_folder, <span class="st">&quot;dual_targeted_gene_calls_t18.tsv&quot;</span>), <span class="dt">sep =</span> <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">            <span class="dt">row.names =</span> <span class="ot">FALSE</span>, <span class="dt">col.names =</span> <span class="ot">TRUE</span>, <span class="dt">quote =</span> <span class="ot">FALSE</span>)</a></code></pre></div>
</div>
<div id="options-for-dual-targeted-scoring" class="section level3">
<h3>Options for dual-targeted scoring</h3>
<p>Dual-targeting scoring can optionally output a residual dataframe of fold-change values per gene-pair, which we can use to visually inspect the quality of top hits. This is returned as the second element in an output list from <code>score_conditions_vs_control</code> with <code>return_residuals=TRUE</code>, where the first element is the scored data as before.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="co"># Scores data and calls significant hits</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">temp &lt;-<span class="st"> </span><span class="kw">score_conditions_vs_control</span>(dual, screens, <span class="st">&quot;HAP1_T18&quot;</span>, <span class="st">&quot;Torin_T18&quot;</span>, </a>
<a class="sourceLine" id="cb14-3" data-line-number="3">                                    <span class="dt">test =</span> <span class="st">&quot;moderated-t&quot;</span>, <span class="dt">loess =</span> <span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">                                    <span class="dt">return_residuals =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">dual_scores2 &lt;-<span class="st"> </span>temp[[<span class="dv">1</span>]]</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">residuals &lt;-<span class="st"> </span>temp[[<span class="dv">2</span>]]</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">dual_scores2 &lt;-<span class="st"> </span><span class="kw">call_significant_response</span>(dual_scores, <span class="st">&quot;HAP1_T18&quot;</span>, <span class="st">&quot;Torin_T18&quot;</span>,</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">                                          <span class="dt">neg_type =</span> <span class="st">&quot;Sensitizer&quot;</span>, <span class="dt">pos_type =</span> <span class="st">&quot;Suppressor&quot;</span>,</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">                                          <span class="dt">differential_threshold =</span> <span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb14-10" data-line-number="10"></a>
<a class="sourceLine" id="cb14-11" data-line-number="11"><span class="co"># Makes LFC plots for all top hits</span></a>
<a class="sourceLine" id="cb14-12" data-line-number="12"><span class="kw">plot_lfc</span>(dual_scores2, residuals, <span class="st">&quot;HAP1_T18&quot;</span>, <span class="st">&quot;Torin_T18&quot;</span>, lfc_folder)</a></code></pre></div>
<p>This alternate way to call <code>score_conditions_vs_control</code> makes plots of LFCs for each significant hit and outputs them to a target folder.</p>
</div>
<div id="paralog-scoring" class="section level3">
<h3>Paralog scoring</h3>
<p>Scoring paralog data is very similar to scoring dual-targeted data, but requires the use of a separate null model that derives expected effects from single-gene knockout effects. Accordingly, a different set of functions with a nearly identical interface is used to <strong>score data against a derived null model.</strong></p>
<p>But first, because we aren’t interested in scoring the effects of non-targeting guides and because this could potentially drastically slow the scoring process, we will remove non-targeting guides from the data.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" data-line-number="1">nt_ind &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">lapply</span>(paralogs, <span class="cf">function</span>(x) x[[<span class="st">&quot;gene1&quot;</span>]] <span class="op">==</span><span class="st"> &quot;NT&quot;</span> <span class="op">|</span><span class="st"> </span>x[[<span class="st">&quot;gene2&quot;</span>]] <span class="op">==</span><span class="st"> &quot;NT&quot;</span>))</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">paralogs &lt;-<span class="st"> </span>paralogs[<span class="op">!</span>nt_ind]</a></code></pre></div>
<p>Scoring the data proceeds in much the same way as for conditions against a control. The only major differences here are that we also pass in single-targeting guides to derive a null model from as well as a list of screens to score separately (with no associated control).</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" data-line-number="1">screens_to_score &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;HAP1_T12&quot;</span>, <span class="st">&quot;HAP1_T18&quot;</span>, <span class="st">&quot;RPE1_T18&quot;</span>, <span class="st">&quot;RPE1_T24&quot;</span>, <span class="st">&quot;Torin_T12&quot;</span>, <span class="st">&quot;Torin_T18&quot;</span>)</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">paralog_scores &lt;-<span class="st"> </span><span class="kw">score_combn_vs_single</span>(paralogs, single, screens, screens_to_score, <span class="dt">test =</span> <span class="st">&quot;moderated-t&quot;</span>)</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">paralog_scores &lt;-<span class="st"> </span><span class="kw">call_significant_response_combn</span>(paralog_scores, screens_to_score,</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">                                                  <span class="dt">neg_type =</span> <span class="st">&quot;Negative GI&quot;</span>, <span class="dt">pos_type =</span> <span class="st">&quot;Positive GI&quot;</span>)</a></code></pre></div>
<p>We then make output plots for all screens.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">plot_significant_response_combn</span>(paralog_scores, <span class="st">&quot;HAP1_T12&quot;</span>, <span class="dt">loess =</span> <span class="ot">TRUE</span>, <span class="dt">neg_type =</span> <span class="st">&quot;Sensitizer&quot;</span>, <span class="dt">pos_type =</span> <span class="st">&quot;Suppressor&quot;</span>)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="kw">ggsave</span>(<span class="kw">file.path</span>(output_folder, <span class="st">&quot;paralog_hap1_t12.png&quot;</span>), <span class="dt">width =</span> <span class="dv">10</span>, <span class="dt">height =</span> <span class="dv">7</span>, <span class="dt">dpi =</span> <span class="dv">300</span>)</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">p &lt;-<span class="st"> </span><span class="kw">plot_significant_response_combn</span>(paralog_scores, <span class="st">&quot;HAP1_T18&quot;</span>, <span class="dt">loess =</span> <span class="ot">TRUE</span>, <span class="dt">neg_type =</span> <span class="st">&quot;Sensitizer&quot;</span>, <span class="dt">pos_type =</span> <span class="st">&quot;Suppressor&quot;</span>)</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="kw">ggsave</span>(<span class="kw">file.path</span>(output_folder, <span class="st">&quot;paralog_hap1_t18.png&quot;</span>), <span class="dt">width =</span> <span class="dv">10</span>, <span class="dt">height =</span> <span class="dv">7</span>, <span class="dt">dpi =</span> <span class="dv">300</span>)</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">p &lt;-<span class="st"> </span><span class="kw">plot_significant_response_combn</span>(paralog_scores, <span class="st">&quot;RPE1_T18&quot;</span>, <span class="dt">loess =</span> <span class="ot">TRUE</span>, <span class="dt">neg_type =</span> <span class="st">&quot;Sensitizer&quot;</span>, <span class="dt">pos_type =</span> <span class="st">&quot;Suppressor&quot;</span>)</a>
<a class="sourceLine" id="cb17-6" data-line-number="6"><span class="kw">ggsave</span>(<span class="kw">file.path</span>(output_folder, <span class="st">&quot;paralog_rpe1_t18.png&quot;</span>), <span class="dt">width =</span> <span class="dv">10</span>, <span class="dt">height =</span> <span class="dv">7</span>, <span class="dt">dpi =</span> <span class="dv">300</span>)</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">p &lt;-<span class="st"> </span><span class="kw">plot_significant_response_combn</span>(paralog_scores, <span class="st">&quot;RPE1_T24&quot;</span>, <span class="dt">loess =</span> <span class="ot">TRUE</span>, <span class="dt">neg_type =</span> <span class="st">&quot;Sensitizer&quot;</span>, <span class="dt">pos_type =</span> <span class="st">&quot;Suppressor&quot;</span>)</a>
<a class="sourceLine" id="cb17-8" data-line-number="8"><span class="kw">ggsave</span>(<span class="kw">file.path</span>(output_folder, <span class="st">&quot;paralog_rpe1_t24.png&quot;</span>), <span class="dt">width =</span> <span class="dv">10</span>, <span class="dt">height =</span> <span class="dv">7</span>, <span class="dt">dpi =</span> <span class="dv">300</span>)</a></code></pre></div>
<p>Even though paralog data is not scored against a control, we still want to compare treated screens against untreated screens in some way. To do that visually, we will also make plots that exclude hits which are significant in a given list of control screens.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">plot_significant_response_combn</span>(paralog_scores, <span class="st">&quot;Torin_T12&quot;</span>, <span class="dt">filter_name =</span> <span class="st">&quot;HAP1_T12&quot;</span>, <span class="dt">loess =</span> <span class="ot">TRUE</span>, <span class="dt">neg_type =</span> <span class="st">&quot;Sensitizer&quot;</span>, <span class="dt">pos_type =</span> <span class="st">&quot;Suppressor&quot;</span>)</a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="kw">ggsave</span>(<span class="kw">file.path</span>(output_folder, <span class="st">&quot;paralog_torin_t12.png&quot;</span>), <span class="dt">width =</span> <span class="dv">10</span>, <span class="dt">height =</span> <span class="dv">7</span>, <span class="dt">dpi =</span> <span class="dv">300</span>)</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">p &lt;-<span class="st"> </span><span class="kw">plot_significant_response_combn</span>(paralog_scores, <span class="st">&quot;Torin_T18&quot;</span>, <span class="dt">filter_name =</span> <span class="st">&quot;HAP1_T18&quot;</span>, <span class="dt">loess =</span> <span class="ot">TRUE</span>, <span class="dt">neg_type =</span> <span class="st">&quot;Sensitizer&quot;</span>, <span class="dt">pos_type =</span> <span class="st">&quot;Suppressor&quot;</span>)</a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="kw">ggsave</span>(<span class="kw">file.path</span>(output_folder, <span class="st">&quot;paralog_torin_t18.png&quot;</span>), <span class="dt">width =</span> <span class="dv">10</span>, <span class="dt">height =</span> <span class="dv">7</span>, <span class="dt">dpi =</span> <span class="dv">300</span>)</a></code></pre></div>
<p>Finally, we save our scored data to file.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">write.table</span>(paralog_scores, <span class="kw">file.path</span>(output_folder, <span class="st">&quot;paralog_gene_calls.tsv&quot;</span>), <span class="dt">sep =</span> <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">            <span class="dt">row.names =</span> <span class="ot">FALSE</span>, <span class="dt">col.names =</span> <span class="ot">TRUE</span>, <span class="dt">quote =</span> <span class="ot">FALSE</span>)</a></code></pre></div>
</div>
<div id="single-targeted-scoring" class="section level3">
<h3>Single-targeted scoring</h3>
<p>ChymeraR also provides a way to score the effect of single-targeted genes (for exonic-intergenic guides that also comprise the null model for combinatorial scoring). Conceptually, this scoring method is the same as the condition vs. control comparison for dual-targeted guides, but is run separately on each orientation. In other words, for our example dataset we can also score conditions vs. controls for Cas9 guides separately from Cas12a guides. The interface to this the same as for dual-targeted scoring, but we provide an additional flag to tell ChymeraR to score orientations separately: <code>orientation=TRUE</code>. We also pass in the single-targeting guides and not the dual-targeting guides.</p>
<p>The main difference between the output of this call to <code>score_conditions_vs_control</code> and the previous ones is the function now returns a list of scored dataframes, one for each orientation. In this dataset, the first element of that list, <code>single_scores[[1]]</code>, contains Cas9 effects and the second, <code>single_scores[[2]]</code>, contains Cas12a effects.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" data-line-number="1">single_scores &lt;-<span class="st"> </span><span class="kw">score_conditions_vs_control</span>(single, screens, <span class="st">&quot;HAP1_T18&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;Torin_T18&quot;</span>), </a>
<a class="sourceLine" id="cb20-2" data-line-number="2">                                             <span class="dt">orientation =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb20-3" data-line-number="3"></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="co"># Only keeps scores from Cas12a guides </span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">single_scores &lt;-<span class="st"> </span>single_scores[[<span class="dv">2</span>]]</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">to_keep &lt;-<span class="st"> </span><span class="op">!</span><span class="kw">is.na</span>(single_scores<span class="op">$</span>gene1)</a>
<a class="sourceLine" id="cb20-7" data-line-number="7"><span class="kw">cat</span>(<span class="kw">paste</span>(<span class="st">&quot;Removing&quot;</span>, <span class="kw">nrow</span>(single_scores) <span class="op">-</span><span class="st"> </span><span class="kw">sum</span>(to_keep), <span class="st">&quot;sparse single-targeting genes</span><span class="ch">\n</span><span class="st">&quot;</span>))</a>
<a class="sourceLine" id="cb20-8" data-line-number="8">single_scores &lt;-<span class="st"> </span>single_scores[to_keep,]</a>
<a class="sourceLine" id="cb20-9" data-line-number="9"></a>
<a class="sourceLine" id="cb20-10" data-line-number="10"><span class="co"># Calls significant hits</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11">single_scores &lt;-<span class="st"> </span><span class="kw">call_significant_response</span>(single_scores, <span class="st">&quot;HAP1_T18&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;Torin_T18&quot;</span>),</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">                                           <span class="dt">neg_type =</span> <span class="st">&quot;Sensitizer&quot;</span>, <span class="dt">pos_type =</span> <span class="st">&quot;Suppressor&quot;</span>,</a>
<a class="sourceLine" id="cb20-13" data-line-number="13">                                           <span class="dt">fdr_threshold =</span> <span class="fl">0.2</span>, <span class="dt">differential_threshold =</span> <span class="fl">0.5</span>)</a></code></pre></div>
<p>Because the library design for the published experiment involved only a few Cas9 guides per gene pair, we’re only interested in scoring the effect of Cas12a guides. So, we only keep the second scored dataframe and look at those effects downstream, after removing gene pairs with too few remaining guides post-filtering.</p>
</div>
</div>
<div id="miscellaneous" class="section level2">
<h2>Miscellaneous</h2>
<div id="differences-from-published-scoring" class="section level3">
<h3>Differences from published scoring</h3>
<p>There are a number of differences between the scoring workflow presented in this vignette and the relatively naive workflow used to score data in Gonatopoulos-Pournatzis et al. The most important differences include:</p>
<ul>
<li>Swapping from Wilcoxon rank-sum hypothesis testing to more sensitive moderated t-testing</li>
<li>Loess-normalizing residuals before performing hypothesis testing</li>
<li>Accurately matching guides based on guide IDs to compute residual effects</li>
<li>Addition of read count-based guide filtering</li>
</ul>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
